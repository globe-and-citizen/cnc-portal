<!-- BankBalanceSection.vue -->
<template>
  <CardComponent title="Balance">
    <div class="flex justify-between items-start">
      <div>
        <div class="flex items-baseline gap-2">
          <span class="text-4xl font-bold">
            <span class="inline-block min-w-16 h-10">
              <span
                class="loading loading-spinner loading-lg"
                v-if="balanceLoading || isLoadingUsdcBalance"
              ></span>
              <span v-else>{{ totalValueUSD }}</span>
            </span>
          </span>
          <span class="text-gray-600">USD</span>
        </div>
        <div class="text-sm text-gray-500 mt-1">
          â‰ˆ {{ totalValueLocal }} {{ currencyStore.currency.code }}
        </div>
      </div>
      <div class="flex flex-col items-end gap-4">
        <div class="flex gap-2">
          <ButtonUI
            v-if="bankAddress"
            variant="secondary"
            class="flex items-center gap-2"
            @click="depositModal = true"
            data-test="deposit-button"
          >
            <PlusIcon class="w-5 h-5" />
            Deposit
          </ButtonUI>
          <ButtonUI
            v-if="bankAddress"
            variant="secondary"
            class="flex items-center gap-2"
            @click="transferModal = true"
            data-test="transfer-button"
          >
            <ArrowsRightLeftIcon class="w-5 h-5" />
            Transfer
          </ButtonUI>
        </div>
        <div class="flex items-center gap-2" v-if="bankAddress">
          <div class="text-sm text-gray-600">Contract Address:</div>
          <AddressToolTip :address="bankAddress" />
        </div>
      </div>
    </div>

    <!-- Deposit Modal -->
    <ModalComponent v-model="depositModal" data-test="deposit-modal">
      <DepositBankForm
        v-if="depositModal"
        @close-modal="() => (depositModal = false)"
        @deposit="depositToBank"
        :loading="
          depositLoading ||
          isConfirmingDeposit ||
          isPendingApprove ||
          isConfirmingApprove ||
          tokenDepositLoading ||
          isConfirmingTokenDeposit
        "
        :loading-text="loadingText"
      />
    </ModalComponent>

    <!-- Transfer Modal -->
    <ModalComponent v-model="transferModal" data-test="transfer-modal">
      <TransferForm
        v-if="transferModal"
        v-model="transferData"
        :tokens="[
          { symbol: NETWORK.currencySymbol, balance: teamBalance?.formatted || '0' },
          { symbol: 'USDC', balance: formattedUsdcBalance || '0' }
        ]"
        :loading="transferLoading || isConfirmingTransfer"
        service="Bank"
        @transfer="handleTransfer"
        @closeModal="() => (transferModal = false)"
      />
    </ModalComponent>
  </CardComponent>
</template>

<script setup lang="ts">
import { PlusIcon, ArrowsRightLeftIcon } from '@heroicons/vue/24/outline'
import ButtonUI from '@/components/ButtonUI.vue'
import AddressToolTip from '@/components/AddressToolTip.vue'
import CardComponent from '@/components/CardComponent.vue'
import { NETWORK, USDC_ADDRESS } from '@/constant'
import {
  useBalance,
  useReadContract,
  useChainId,
  useSendTransaction,
  useWaitForTransactionReceipt,
  useWriteContract
} from '@wagmi/vue'
import { computed, ref, watch } from 'vue'
import type { Address } from 'viem'
import ERC20ABI from '@/artifacts/abi/erc20.json'
import { useToastStore } from '@/stores/useToastStore'
import { log, parseError } from '@/utils'
import ModalComponent from '@/components/ModalComponent.vue'
import DepositBankForm from '@/components/forms/DepositBankForm.vue'
import TransferForm from '@/components/forms/TransferForm.vue'
import { useUserDataStore } from '@/stores/user'
import { useCurrencyStore } from '@/stores/currencyStore'
import BankABI from '@/artifacts/abi/bank.json'
import { readContract } from '@wagmi/core'
import { config } from '@/wagmi.config'
import { parseEther } from 'viem'
import { useCryptoPrice } from '@/composables/useCryptoPrice'

const props = defineProps<{
  bankAddress: Address | undefined
}>()

const emit = defineEmits<{
  (e: 'error'): void
  (e: 'balance-updated'): void
}>()

const { addErrorToast, addSuccessToast } = useToastStore()
const userDataStore = useUserDataStore()
const currencyStore = useCurrencyStore()
const { price: usdcPrice, priceInUSD: usdcInUSD } = useCryptoPrice('usd-coin')
const currentAddress = userDataStore.address
const chainId = useChainId()

// Add refs for modals and form data
const depositModal = ref(false)
const transferModal = ref(false)
const depositAmount = ref('')
const transferData = ref({
  address: { name: '', address: '' },
  token: { symbol: NETWORK.currencySymbol, balance: '0' },
  amount: '0'
})

// Contract interactions
const { sendTransaction, isPending: depositLoading, data: depositHash } = useSendTransaction()

const { isLoading: isConfirmingDeposit } = useWaitForTransactionReceipt({
  hash: depositHash
})

const {
  data: transferHash,
  isPending: transferLoading,
  writeContract: transfer
} = useWriteContract()

const { isLoading: isConfirmingTransfer } = useWaitForTransactionReceipt({
  hash: transferHash
})

const {
  writeContract: writeTokenDeposit,
  isPending: tokenDepositLoading,
  data: tokenDepositHash
} = useWriteContract()

const { isLoading: isConfirmingTokenDeposit } = useWaitForTransactionReceipt({
  hash: tokenDepositHash
})

const {
  writeContract: approve,
  isPending: isPendingApprove,
  data: approveHash
} = useWriteContract()

const { isLoading: isConfirmingApprove } = useWaitForTransactionReceipt({
  hash: approveHash
})

// Balance fetching
const {
  data: teamBalance,
  isLoading: balanceLoading,
  error: balanceError,
  refetch: fetchBalance
} = useBalance({
  address: props.bankAddress,
  chainId
})

// USDC Balance
const {
  data: usdcBalance,
  isLoading: isLoadingUsdcBalance,
  refetch: fetchUsdcBalance,
  error: usdcBalanceError
} = useReadContract({
  address: USDC_ADDRESS as Address,
  abi: ERC20ABI,
  functionName: 'balanceOf',
  args: [props.bankAddress as Address]
})

// Functions
const depositToBank = async (data: { amount: string; token: string }) => {
  if (!props.bankAddress) return

  try {
    if (data.token === 'ETH') {
      sendTransaction({
        to: props.bankAddress,
        value: parseEther(data.amount)
      })
    } else if (data.token === 'USDC') {
      const amount = BigInt(Number(data.amount) * 1e6)
      depositAmount.value = data.amount // Store amount for after approval

      const allowance = await readContract(config, {
        address: USDC_ADDRESS as Address,
        abi: ERC20ABI,
        functionName: 'allowance',
        args: [currentAddress as Address, props.bankAddress]
      })

      const currentAllowance = allowance ? allowance.toString() : 0n
      if (Number(currentAllowance) < Number(amount)) {
        approve({
          address: USDC_ADDRESS as Address,
          abi: ERC20ABI,
          functionName: 'approve',
          args: [props.bankAddress, amount]
        })
      } else {
        // If already approved, deposit directly
        await handleUsdcDeposit(data.amount)
      }
    }
  } catch (error) {
    console.error(error)
    addErrorToast(`Failed to deposit ${data.token}`)
  }
}

const handleUsdcDeposit = async (amount: string) => {
  if (!props.bankAddress) return
  const tokenAmount = BigInt(Number(amount) * 1e6)

  writeTokenDeposit({
    address: props.bankAddress,
    abi: BankABI,
    functionName: 'depositToken',
    args: [USDC_ADDRESS as Address, tokenAmount]
  })
}

const handleTransfer = async (data: {
  address: { address: string }
  token: { symbol: string }
  amount: string
}) => {
  if (!props.bankAddress) return

  try {
    if (data.token.symbol === NETWORK.currencySymbol) {
      transfer({
        address: props.bankAddress,
        abi: BankABI,
        functionName: 'transfer',
        args: [data.address.address, parseEther(data.amount)]
      })
    } else if (data.token.symbol === 'USDC') {
      const tokenAmount = BigInt(Number(data.amount) * 1e6)
      transfer({
        address: props.bankAddress,
        abi: BankABI,
        functionName: 'transferToken',
        args: [USDC_ADDRESS as Address, data.address.address, tokenAmount]
      })
    }
  } catch (error) {
    console.error(error)
    addErrorToast(`Failed to transfer ${data.token.symbol}`)
  }
}

// Computed properties
const formattedUsdcBalance = computed(() =>
  usdcBalance.value ? (Number(usdcBalance.value) / 1e6).toString() : '0'
)

const loadingText = computed(() => {
  if (isPendingApprove.value) return 'Approving USDC...'
  if (isConfirmingApprove.value) return 'Confirming USDC approval...'
  if (tokenDepositLoading.value) return 'Depositing USDC...'
  if (isConfirmingTokenDeposit.value) return 'Confirming USDC deposit...'
  if (depositLoading.value) return 'Depositing ETH...'
  if (isConfirmingDeposit.value) return 'Confirming ETH deposit...'
  return 'Processing...'
})

const totalValueUSD = computed(() => {
  const ethValue = teamBalance.value
    ? Number(teamBalance.value.formatted) * (currencyStore.nativeTokenPriceInUSD || 0)
    : 0
  const usdcValue = Number(formattedUsdcBalance.value) * (usdcInUSD.value || 0)
  return (ethValue + usdcValue).toFixed(2)
})

const totalValueLocal = computed(() => {
  const usdValue = Number(totalValueUSD.value)
  return (usdValue * (usdcPrice.value || 0)).toFixed(2)
})

// Watch handlers
watch(balanceError, () => {
  if (balanceError.value) {
    addErrorToast('Failed to fetch team balance')
    log.error('Failed to fetch team balance:', parseError(balanceError.value))
    emit('error')
  }
})

watch([teamBalance, usdcBalance], () => {
  emit('balance-updated')
})

watch(
  () => props.bankAddress,
  async (newAddress) => {
    if (newAddress) {
      await Promise.all([fetchBalance(), fetchUsdcBalance()])
    }
  }
)

watch(isConfirmingDeposit, (newIsConfirming, oldIsConfirming) => {
  if (!newIsConfirming && oldIsConfirming) {
    addSuccessToast('ETH deposited successfully')
    depositModal.value = false
    fetchBalance()
  }
})

watch(isConfirmingTransfer, (newIsConfirming, oldIsConfirming) => {
  if (!newIsConfirming && oldIsConfirming) {
    addSuccessToast('Transferred successfully')
    transferModal.value = false
    Promise.all([fetchBalance(), fetchUsdcBalance()])
  }
})

watch(isConfirmingTokenDeposit, (newIsConfirming, oldIsConfirming) => {
  if (!newIsConfirming && oldIsConfirming) {
    addSuccessToast('USDC deposited successfully')
    depositModal.value = false
    fetchUsdcBalance()
    depositAmount.value = '' // Clear stored amount
  }
})

watch(isConfirmingApprove, async (newIsConfirming, oldIsConfirming) => {
  if (!newIsConfirming && oldIsConfirming) {
    addSuccessToast('Token approved successfully')
    if (depositAmount.value) {
      await handleUsdcDeposit(depositAmount.value)
    }
  }
})

// Expose methods and data for parent component
defineExpose({
  teamBalance,
  formattedUsdcBalance,
  balanceError,
  usdcBalanceError,
  fetchBalance,
  fetchUsdcBalance
})
</script>
