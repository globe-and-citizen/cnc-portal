<template>
  <ButtonUI
    variant="primary"
    :loading="createOfficerLoading"
    :disabled="disable || createOfficerLoading"
    data-test="deploy-contracts-button"
    @click="deployOfficerContract()"
  >
    Deploy Contracts
  </ButtonUI>
</template>

<script lang="ts" setup>
import { useUserDataStore } from '@/stores/user'
import ButtonUI from '@/components/ButtonUI.vue'
import { useToastStore } from '@/stores/useToastStore'
import type { Team } from '@/types'
import { useWriteContract, useWaitForTransactionReceipt, useWatchContractEvent } from '@wagmi/vue'
import { encodeFunctionData, type Address } from 'viem'
import { ref, watch, computed } from 'vue'

// Contract ABIs
import { OFFICER_ABI } from '@/artifacts/abi/officer'
import { BANK_ABI } from '@/artifacts/abi/bank'
// import { VOTING_ABI } from '@/artifacts/abi/voting'

import { EXPENSE_ACCOUNT_EIP712_ABI } from '@/artifacts/abi/expense-account-eip712'
import { CASH_REMUNERATION_EIP712_ABI } from '@/artifacts/abi/cash-remuneration-eip712'
import { FACTORY_BEACON_ABI } from '@/artifacts/abi/factory-beacon'
import { ELECTIONS_ABI } from '@/artifacts/abi/elections'

import {
  BANK_BEACON_ADDRESS,
  BOD_BEACON_ADDRESS,
  CASH_REMUNERATION_EIP712_BEACON_ADDRESS,
  EXPENSE_ACCOUNT_EIP712_BEACON_ADDRESS,
  INVESTOR_V1_BEACON_ADDRESS,
  OFFICER_BEACON,
  PROPOSALS_BEACON_ADDRESS,
  USDC_ADDRESS,
  USDT_ADDRESS,
  validateAddresses,
  // VOTING_BEACON_ADDRESS,
  ELECTIONS_BEACON_ADDRESS
  // OFFICER_ADDRESS
} from '@/constant'
import { INVESTOR_ABI } from '@/artifacts/abi/investorsV1'
import { useCustomFetch } from '@/composables/useCustomFetch'
import { log } from '@/utils'
import { PROPOSALS_ABI } from '@/artifacts/abi/proposals'

const props = withDefaults(
  defineProps<{
    investorContractInput: { name: string; symbol: string }
    createdTeamData: Partial<Team>
    disable?: boolean
  }>(),
  {
    disable: false
  }
)
const emits = defineEmits(['contractDeployed'])
// Store
const userDataStore = useUserDataStore()
const { addSuccessToast, addErrorToast } = useToastStore()

const loading = ref(false)
const dynamicLoading = ref({
  status: false,
  message: ''
})

// Officer contract creation
const {
  isPending: officerContractCreating,
  data: createOfficerHash,
  error: createOfficerError,
  writeContract: createOfficer
} = useWriteContract()

const { isLoading: isConfirmingCreateOfficer, isSuccess: isConfirmedCreateOfficer } =
  useWaitForTransactionReceipt({
    hash: createOfficerHash
  })

const createOfficerLoading = computed(
  () => officerContractCreating.value || isConfirmingCreateOfficer.value || loading.value
)

const deployOfficerContract = async () => {
  loading.value = true
  try {
    // TODO: Check if the address in the store is the same as the address in the connected wallet
    const currentUserAddress = userDataStore.address as Address

    console.log('Validating addresses')
    validateAddresses()
    if (!props.createdTeamData?.id) {
      loading.value = false
      return
    }

    if (
      !BANK_BEACON_ADDRESS ||
      !BOD_BEACON_ADDRESS ||
      !PROPOSALS_BEACON_ADDRESS ||
      !EXPENSE_ACCOUNT_EIP712_BEACON_ADDRESS ||
      !CASH_REMUNERATION_EIP712_BEACON_ADDRESS ||
      !INVESTOR_V1_BEACON_ADDRESS ||
      !ELECTIONS_BEACON_ADDRESS
    ) {
      addErrorToast('One or more beacon addresses are not defined. Cannot deploy contracts.')
      loading.value = false
      return
    }

    const beaconConfigs: Array<{ beaconType: string; beaconAddress: Address }> = [
      {
        beaconType: 'Bank',
        beaconAddress: BANK_BEACON_ADDRESS
      },
      {
        beaconType: 'BoardOfDirectors',
        beaconAddress: BOD_BEACON_ADDRESS
      },
      {
        beaconType: 'Proposals',
        beaconAddress: PROPOSALS_BEACON_ADDRESS
      },
      {
        beaconType: 'ExpenseAccountEIP712',
        beaconAddress: EXPENSE_ACCOUNT_EIP712_BEACON_ADDRESS
      },
      {
        beaconType: 'CashRemunerationEIP712',
        beaconAddress: CASH_REMUNERATION_EIP712_BEACON_ADDRESS
      },
      {
        beaconType: 'InvestorV1',
        beaconAddress: INVESTOR_V1_BEACON_ADDRESS
      },
      {
        beaconType: 'Elections',
        beaconAddress: ELECTIONS_BEACON_ADDRESS
      }
    ]
    const deployments = []

    // Bank contract
    deployments.push({
      contractType: 'Bank',
      initializerData: encodeFunctionData({
        abi: BANK_ABI,
        functionName: 'initialize',
        args: [[USDT_ADDRESS, USDC_ADDRESS], currentUserAddress]
      })
    })
    deployments.push({
      contractType: 'InvestorV1',
      initializerData: encodeFunctionData({
        abi: INVESTOR_ABI,
        functionName: 'initialize',
        args: [
          props.investorContractInput.name,
          props.investorContractInput.symbol,
          currentUserAddress
        ]
      })
    })

    // Voting contract
    // deployments.push({
    //   contractType: 'Voting',
    //   initializerData: encodeFunctionData({
    //     abi: VotingABI,
    //     functionName: 'initialize',
    //     args: [currentUserAddress]
    //   })
    // })

    // Proposal contract
    deployments.push({
      contractType: 'Proposals',
      initializerData: encodeFunctionData({
        abi: PROPOSALS_ABI,
        functionName: 'initialize',
        args: [currentUserAddress]
      })
    })

    // Expense account EIP712
    deployments.push({
      contractType: 'ExpenseAccountEIP712',
      initializerData: encodeFunctionData({
        abi: EXPENSE_ACCOUNT_EIP712_ABI,
        functionName: 'initialize',
        args: [currentUserAddress, USDT_ADDRESS, USDC_ADDRESS]
      })
    })

    // Cash remuneration EIP712
    deployments.push({
      contractType: 'CashRemunerationEIP712',
      initializerData: encodeFunctionData({
        abi: CASH_REMUNERATION_EIP712_ABI,
        functionName: 'initialize',
        args: [currentUserAddress, [USDC_ADDRESS]]
      })
    })

    // Elections contract
    deployments.push({
      contractType: 'Elections',
      initializerData: encodeFunctionData({
        abi: ELECTIONS_ABI,
        functionName: 'initialize',
        args: [currentUserAddress]
      })
    })

    const encodedFunction = encodeFunctionData({
      abi: OFFICER_ABI,
      functionName: 'initialize',
      args: [currentUserAddress, beaconConfigs, deployments, true]
    })

    if (!OFFICER_BEACON) {
      log.error('Officer Beacon address is not defined')
      addErrorToast('Officer Beacon address is not defined')
      loading.value = false
      return
    }
    createOfficer({
      address: OFFICER_BEACON,
      abi: FACTORY_BEACON_ABI,
      functionName: 'createBeaconProxy',
      args: [encodedFunction]
    })
  } catch (error) {
    // console.log('Error deploying contract V2', error)
    loading.value = false
    if (typeof error === 'object' && error !== null && 'message' in error) {
      console.log('Error deploying contract V2', error.message)
    } else {
      console.log('Error deploying contract V2')
    }
    // log.error('Error deploying contract')
    // log.error(String( || error))
    addErrorToast('Error deploying contract')
    loading.value = false
  } finally {
    dynamicLoading.value = {
      ...dynamicLoading.value,
      message: 'Officer Contract Ready for deployement'
    }
  }
}

watch(createOfficerError, (error) => {
  if (error) {
    log.error('Failed to create officer contract')
    log.error(String(error))
    addErrorToast('Failed to create officer contract')
    loading.value = false
  }
})

watch([isConfirmingCreateOfficer, isConfirmedCreateOfficer], ([isConfirming, isConfirmed]) => {
  if (!isConfirming && isConfirmed) {
    dynamicLoading.value = {
      ...dynamicLoading.value,
      message: 'Officer Contract deployed successfully'
    }
    addSuccessToast('Officer contract deployed successfully')
    // Continue with team creation
  }
})

useWatchContractEvent({
  address: OFFICER_BEACON as Address,
  abi: FACTORY_BEACON_ABI,
  eventName: 'BeaconProxyCreated',
  async onLogs(logs) {
    console.log('try get BeaconProxyCreated logs')
    if (!logs.length) {
      log.error('No logs found')
      loading.value = false
      return
    }
    if (logs[0].transactionHash !== createOfficerHash.value) {
      log.error('Transaction hash does not match')
      loading.value = false
      return
    }

    interface ILogs {
      args: {
        deployer: Address
        proxy: Address
      }
    }
    const deployer = (logs[0] as unknown as ILogs).args.deployer
    const proxyAddress = (logs[0] as unknown as ILogs).args.proxy
    const currentAddress = userDataStore.address as Address

    if (currentAddress !== deployer) {
      log.error('Deployer address does not match, with the current user address')
      addErrorToast('Deployer address does not match, with the current user address')
      loading.value = false
      return
    }
    if (!props.createdTeamData.id) {
      log.error('No team data found')
      addErrorToast('No team data found')
      loading.value = false
      return
    }

    const { error: updateTeamError } = await useCustomFetch<string>(
      `teams/${props.createdTeamData.id}`
    )
      .put({
        officerAddress: proxyAddress
      })
      .json()
    if (updateTeamError.value) {
      log.error('Error updating officer address')
      addErrorToast('Error updating officer address')
      loading.value = false
      return
    }
    const { error: updateContractsError } = await useCustomFetch('contract/sync')
      .put({ teamId: props.createdTeamData.id })
      .json()

    if (updateContractsError.value) {
      log.error('Error updating contracts')
      addErrorToast('Error updating contracts')
      loading.value = false
      return
    }
    dynamicLoading.value = {
      message: 'Loaded',
      status: false
    }
    loading.value = false
    emits('contractDeployed')
  }
})
</script>
