<template>
  <ButtonUI
    v-if="claim.status == 'signed'"
    :disabled="userDataStore.address != claim.wage.user.address"
    :loading="isLoading"
    variant="warning"
    data-test="withdraw-button"
    @click="async () => await withdrawClaim()"
    >Withdraw</ButtonUI
  >
</template>

<script setup lang="ts">
import { useTeamStore, useToastStore, useUserDataStore } from '@/stores'
import type { ClaimResponse } from '@/types'
import { log } from '@/utils'
import { useWaitForTransactionReceipt, useWriteContract } from '@wagmi/vue'
import { formatEther, parseEther, type Address } from 'viem'
import { ref } from 'vue'
import EIP712ABI from '@/artifacts/abi/CashRemunerationEIP712.json'
import { getBalance } from 'viem/actions'
import { config } from '@/wagmi.config'
import { useCustomFetch } from '@/composables'
import ButtonUI from '@/components/ButtonUI.vue'

const props = defineProps<{ claim: ClaimResponse }>()
const emit = defineEmits(['claim-withdrawn'])

const userDataStore = useUserDataStore()
const teamStore = useTeamStore()
const toastStore = useToastStore()

const {
  writeContractAsync: withdraw,
  data: withdrawHash,
  error: withdrawError
} = useWriteContract()

const { isSuccess: withdrawSuccess, error: withdrawTrxError } = useWaitForTransactionReceipt({
  hash: withdrawHash
})

const { execute: updateClaimStatus } = useCustomFetch(`/claim/${props.claim.id}/widrawn`, {
  immediate: false
})
  .put()
  .json()

const isLoading = ref(false)

const withdrawClaim = async () => {
  isLoading.value = true
  // balance check
  const balance = formatEther(
    await getBalance(config.getClient(), {
      address: teamStore.currentTeam?.cashRemunerationEip712Address as Address
    })
  )
  if (
    Number(balance) <
    Number(props.claim.wage.cashRatePerHour) * Number(props.claim.hoursWorked)
  ) {
    isLoading.value = false
    toastStore.addErrorToast('Insufficient balance')
    return
  }

  // withdraw
  try {
    await withdraw({
      abi: EIP712ABI,
      address: teamStore.currentTeam?.cashRemunerationEip712Address as Address,
      functionName: 'withdraw',
      args: [
        {
          hourlyRate: parseEther(String(props.claim.wage.cashRatePerHour)),
          hoursWorked: props.claim.hoursWorked,
          employeeAddress: props.claim.wage.user.address as Address,
          date: BigInt(Math.floor(new Date(props.claim.createdAt).getTime() / 1000))
        },
        props.claim.signature
      ]
    })
  } catch (error) {
    toastStore.addErrorToast('Failed to withdraw claim')
    log.info('Withdraw error', error)
  }
  isLoading.value = false

  if (withdrawSuccess.value) {
    toastStore.addSuccessToast('Claim withdrawn')
  }
  if (withdrawError.value) {
    toastStore.addErrorToast('Failed to withdraw claim')
  }
  if (withdrawTrxError.value) {
    toastStore.addErrorToast('Trx failed: Failed to withdraw claim')
  }
  await updateClaimStatus()

  if (withdrawError.value) {
    toastStore.addErrorToast('Failed to withdraw claim')
  }

  // chek if claim is updated
  if (withdrawSuccess.value) {
    emit('claim-withdrawn')
  }
  isLoading.value = false
}
</script>

<style scoped></style>
