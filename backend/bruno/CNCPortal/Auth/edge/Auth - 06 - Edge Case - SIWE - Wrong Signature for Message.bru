meta {
  name: Auth - 06 - Edge Case - SIWE - Wrong Signature for Message
  type: http
  seq: 6
}

post {
  url: {{host}}/auth/siwe
  body: json
  auth: none
}

script:pre-request {
  // Get a fresh nonce first
  const nonce = bru.getVar("userNonce") || "test123";
  console.log("Using nonce for wrong signature test:", nonce);
  bru.setVar("testNonce", nonce);
}

body:json {
  {
    "message": "localhost wants you to sign in with your Ethereum account:\n0xf39Fd6e51aad88F6F4ce6aB8827279cffFb92266\n\nI accept the MetaMask Terms of Service: https://community.metamask.io/tos\n\nURI: http://localhost:3000\nVersion: 1\nChain ID: 1\nNonce: {{testNonce}}\nIssued At: 2025-10-30T08:00:00.000Z",
    "signature": "0x1234567890abcdef1234567890abcdef1234567890abcdef1234567890abcdef1234567890abcdef1234567890abcdef1234567890abcdef1234567890abcdef12"
  }
}

tests {
  test("should handle cryptographic verification failure", function() {
    // May return 401 (auth error) or 500 (if SIWE parsing throws unhandled error)
    const status = res.getStatus();
    expect([401, 500]).to.include(status);
  });

  test("should handle signature verification gracefully", function() {
    expect(res.body.message).to.be.a('string');
    expect(res.body.message.length).to.be.greaterThan(0);
    
    // Should NOT contain format validation errors since signature format is correct
    expect(res.body.message).to.not.contain("Invalid signature format");
    expect(res.body.message).to.not.contain("0x followed by 130 hexadecimal characters");
    
    if (res.getStatus() === 500) {
      // If backend throws 500, it should still be handled gracefully
      expect(res.body.message).to.contain("Internal server error");
    } else {
      // If properly handled, should indicate authentication failure
      const message = res.body.message.toLowerCase();
      const hasAuthError = message.includes('authentication') || 
                          message.includes('verification') || 
                          message.includes('invalid') ||
                          message.includes('failed') ||
                          message.includes('unauthorized');
      expect(hasAuthError).to.be.true;
    }
  });

  test("should not expose sensitive cryptographic details", function() {
    // Should not contain stack traces, but may contain parsing errors in 500 response
    expect(res.body.message).to.not.contain("at ");
    expect(res.body.message).to.not.contain("TypeError");
    expect(res.body.message).to.not.contain("secp256k1");
    
    // If it's a 500 error, it may contain SIWE parsing details but not crypto internals
    if (res.getStatus() === 500) {
      expect(res.body.message).to.not.contain("private key");
      expect(res.body.message).to.not.contain("secret");
    }
  });
}