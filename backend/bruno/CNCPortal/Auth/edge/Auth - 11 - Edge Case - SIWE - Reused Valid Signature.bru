meta {
  name: Auth - 11 - Edge Case - SIWE - Reused Valid Signature
  type: http
  seq: 11
}

post {
  url: {{host}}/auth/siwe
  body: json
  auth: none
}

script:pre-request {
  // Test with a previously used signature pattern
  // This simulates attempting to reuse a signature that was valid before
  const testMessage = "localhost wants you to sign in with your Ethereum account:\\n0xf39Fd6e51aad88F6F4ce6aB8827279cffFb92266\\n\\nI accept the MetaMask Terms of Service: https://community.metamask.io/tos\\n\\nURI: http://localhost:3000\\nVersion: 1\\nChain ID: 1\\nNonce: previously-used-nonce\\nIssued At: 2025-10-30T08:00:00.000Z";
  const testSignature = "0x1234567890abcdef1234567890abcdef1234567890abcdef1234567890abcdef1234567890abcdef1234567890abcdef1234567890abcdef1234567890abcdef1234";
  
  bru.setVar("testReusedMessage", testMessage);
  bru.setVar("testReusedSignature", testSignature);
  
  console.log("Testing reused signature scenario");
}

body:json {
  {
    "message": "{{testReusedMessage}}",
    "signature": "{{testReusedSignature}}"
  }
}

tests {
  test("should reject reused/invalid signature with appropriate status", function() {
    const status = res.getStatus();
    expect([400, 401]).to.include(status);
  });

  test("should return signature or authentication related error", function() {
    expect(res.body.message).to.be.a('string');
    expect(res.body.message.length).to.be.greaterThan(0);
    
    // Should indicate signature reuse, authentication, or verification failure
    const message = res.body.message.toLowerCase();
    const hasSignatureError = message.includes('signature') || 
                             message.includes('reuse') || 
                             message.includes('invalid') ||
                             message.includes('authentication') ||
                             message.includes('verification') ||
                             message.includes('nonce');
    
    expect(hasSignatureError).to.be.true;
  });

  test("should handle signature reuse securely", function() {
    // Should not expose signature verification details or replay attack info
    expect(res.body.message).to.not.contain("replay");
    expect(res.body.message).to.not.contain("cache");
    expect(res.body.message).to.not.contain("stored");
    expect(res.getStatus()).to.not.equal(500);
  });
}